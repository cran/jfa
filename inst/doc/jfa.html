<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Koen Derks" />


<title>Get started</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Get started</h1>
<h4 class="author">Koen Derks</h4>
<h4 class="date">last modified: 27-10-2021</h4>


<div id="TOC">
<ul>
<li><a href="#example-data">Example data</a></li>
<li><a href="#optional-using-auditprior-the-basics">(Optional) Using
<code>auditPrior()</code>: The basics</a></li>
<li><a href="#using-planning-the-basics">Using <code>planning()</code>:
The basics</a>
<ul>
<li><a href="#hypothesis-testing">Hypothesis testing</a></li>
<li><a href="#estimation">Estimation</a></li>
</ul></li>
<li><a href="#using-selection-the-basics">Using
<code>selection()</code>: The basics</a>
<ul>
<li><a href="#record-sampling">Record sampling</a></li>
<li><a href="#monetary-unit-sampling-mus">Monetary unit sampling
(MUS)</a></li>
<li><a href="#extracting-the-sample">Extracting the sample</a></li>
</ul></li>
<li><a href="#using-evaluation-the-basics">Using
<code>evaluation()</code>: The basics</a>
<ul>
<li><a href="#summary-statistics">Summary statistics</a></li>
<li><a href="#data-sample">Data sample</a></li>
</ul></li>
<li><a href="#using-report-the-basics">Using <code>report()</code>: The
basics</a></li>
</ul>
</div>

<p>Welcome to the ‘Get started’ vignette of the <code>jfa</code>
package. This vignette provides a simple explanation of the functions in
the package and how they facilitate the statistical audit sampling
workflow. See the other vignettes for a more detailed explanation of the
functionality of the package.</p>
<div id="example-data" class="section level2">
<h2>Example data</h2>
<p>To concretely illustrate <code>jfa</code>‘s functionality, we
consider the <code>BuildIt</code> data set that is included in the
package (for more info, see <code>?BuildIt</code>). This data set
contains a population of 3500 invoices paid to the fictional ’BuildIt’
construction company. Each invoice has an identification number
(<code>ID</code>), a recorded value (<code>bookValue</code>), and a
corresponding audit (true) value (<code>auditValue</code>).</p>
<p><strong>Note:</strong> The information in the <code>auditValue</code>
column is added for illustrative purposes since it will only be known to
the auditor after having inspected a sample of invoices.</p>
<p>First, we load the <code>jfa</code> package and the
<code>BuildIt</code> data set. The first 10 invoices from the data set
are displayed below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(jfa)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&#39;BuildIt&#39;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(BuildIt, <span class="at">n =</span> <span class="dv">10</span>)</span></code></pre></div>
<pre><code>##       ID bookValue auditValue
## 1  82884    242.61     242.61
## 2  25064    642.99     642.99
## 3  81235    628.53     628.53
## 4  71769    431.87     431.87
## 5  55080    620.88     620.88
## 6  93224    501.76     501.76
## 7  24331    466.01     466.01
## 8  81460    295.20     295.20
## 9  14608    216.48     216.48
## 10 79064    243.43     243.43</code></pre>
<p>For a fully illustrated walkthrough of <code>jfa</code>’s workflow
functionality using the <code>BuildIt</code> data set, see <a href="https://koenderks.github.io/jfa/articles/v1_sampling_workflow.html">Workflow:
Classical audit sampling</a>. For a Bayesian version of the illustrated
walkthrough, see <a href="https://koenderks.github.io/jfa/articles/v2_bayesian_sampling_workflow.html">Workflow:
Bayesian audit sampling</a>.</p>
</div>
<div id="optional-using-auditprior-the-basics" class="section level2">
<h2>(Optional) Using <code>auditPrior()</code>: The basics</h2>
<p>The <code>auditPrior()</code> function can be used to create a prior
distribution for the misstatement parameter in a statistical audit
sampling model. In an audit sampling context, an advantage of Bayesian
inference is that the prior distribution can be used to incorporate
existing information into the statistical procedure. Incorporating
existing information can potentially yield a decrease in sample size and
an increase in efficiency. The type of audit information that can be
incorporated depends on the information that is available in the context
of the audit. See the vignette <a href="https://koenderks.github.io/jfa/articles/v3_prior_distributions.html">Planning:
Prior distributions</a> or the accompanying <a href="https://onlinelibrary.wiley.com/doi/10.1111/ijau.12240">article</a>
for a detailed explanation of the types of audit information that
<code>jfa</code> is able to incorporate into a prior distribution.</p>
<p>With the prior distribution in hand, Bayesian audit sampling can be
performed by providing the object returned by the
<code>auditPrior()</code> function as input for the <code>prior</code>
argument in subsequent calls to the <code>planning()</code> and
<code>evaluation()</code> functions.</p>
</div>
<div id="using-planning-the-basics" class="section level2">
<h2>Using <code>planning()</code>: The basics</h2>
<p>Planning a minimum sample size requires knowledge of the conditions
that lead to acceptance of the population (i.e., the sampling
objectives). Generally, a sampling objective can be one (or both) of the
following:</p>
<ul>
<li><strong>Hypothesis testing</strong>: Obtain measures of evidence for
the claim that the misstatement in the population is lower than a given
performance materiality (i.e., the maximum tolerable misstatement).</li>
<li><strong>Estimation</strong>: Obtain measures of accuracy for the
claim that the misstatement in the population is a certain value (with a
minimum precision).</li>
</ul>
<p>Next to determining the sampling objective(s), it is also important
to determine the statistical distribution linking the sample outcomes to
the population misstatement (e.g., <code>poisson</code>,
<code>binomial</code>, or <code>hypergeometric</code>). All three
distributions are standard in an audit sampling context because they are
(approximations) of the hypergeometric distribution, but
<code>poisson</code> is the default in <code>jfa</code> because it is
the most conservative.</p>
<p>Lastly, it is advised to obtain knowledge of the expected (or
tolerable) errors in the sample. It is strongly recommended to set the
value for the expected errors in the sample conservatively to minimize
the chance of the observed errors in the sample exceeding the expected
errors, which would imply that insufficient work has been done in the
end.</p>
<p>With the <code>BuildIt</code> data set, because the booked amounts
(monetary values) of each invoice in the population are given, an
auditor may want to make a statement about the amount of misstatement in
the population. For illustrative purposes we will tolerate zero
misstatements in the sample.</p>
<div id="hypothesis-testing" class="section level3">
<h3>Hypothesis testing</h3>
<p>First, let’s take a look at how you can use the
<code>planning()</code> function to calculate the minimum sample size
for testing the hypothesis that the misstatement in the population is
lower than the performance materiality. In this example the performance
materiality is set to 5% of the total population value, meaning that the
population may not contain more than 5% misstatement.</p>
<p><strong>Sampling objective</strong>: Calculate a minimum sample size
such that, when no misstatements are found in the sample, there is a 95%
chance that the misstatement in the population is lower than 5% of the
population value.</p>
<p>A minimum sample size for this sampling objective can be calculated
by specifying the <code>materiality</code> parameter in the
<code>planning()</code> function, see the code below. Next, a summary of
the statistical results can be obtained using the <code>summary()</code>
function. The results show that, given zero tolerable errors, the
minimum sample size is 60 units.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>stage1 <span class="ot">&lt;-</span> <span class="fu">planning</span>(<span class="at">materiality =</span> <span class="fl">0.05</span>, <span class="at">expected =</span> <span class="dv">0</span>, <span class="at">likelihood =</span> <span class="st">&#39;poisson&#39;</span>, <span class="at">conf.level =</span> <span class="fl">0.95</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(stage1)</span></code></pre></div>
<pre><code>## 
##  Classical Audit Sample Planning Summary
## 
## Options:
##   Confidence level:              0.95 
##   Materiality:                   0.05 
##   Hypotheses:                    H₀: Θ &gt;= 0.05 vs. H₁: Θ &lt; 0.05 
##   Expected:                      0 
##   Likelihood:                    poisson 
## 
## Results:
##   Minimum sample size:           60 
##   Tolerable errors:              0 
##   Expected most likely error:    0 
##   Expected upper bound:          0.049929 
##   Expected precision:            0.049929 
##   Expected p-value:              &lt; 2.22e-16</code></pre>
</div>
<div id="estimation" class="section level3">
<h3>Estimation</h3>
<p>Next, let’s take a look at how you can use the
<code>planning()</code> function to calculate the minimum sample size
for estimating the misstatement in the population with a minimum
precision. The precision is defined as the difference between the most
likely misstatement and the upper confidence bound on the misstatement.
For this example, the minimum precision is set to 2% of the population
value.</p>
<p><strong>Sampling objective</strong>: Calculate a minimum sample size
such that, when zero misstatements are found in the sample, there is a
95% chance that the misstatement in the population is at most 2% above
the most likely misstatement.</p>
<p>A minimum sample size for this sampling objective can be calculated
by specifying the <code>min.precision</code> parameter in the
<code>planning()</code> function, see the code below. The results show
that, given zero tolerable errors, the minimum sample size is 150
units.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>stage1 <span class="ot">&lt;-</span> <span class="fu">planning</span>(<span class="at">min.precision =</span> <span class="fl">0.02</span>, <span class="at">expected =</span> <span class="dv">0</span>, <span class="at">likelihood =</span> <span class="st">&#39;poisson&#39;</span>, <span class="at">conf.level =</span> <span class="fl">0.95</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(stage1)</span></code></pre></div>
<pre><code>## 
##  Classical Audit Sample Planning Summary
## 
## Options:
##   Confidence level:              0.95 
##   Min. precision:                0.02 
##   Expected:                      0 
##   Likelihood:                    poisson 
## 
## Results:
##   Minimum sample size:           150 
##   Tolerable errors:              0 
##   Expected most likely error:    0 
##   Expected upper bound:          0.019971 
##   Expected precision:            0.019971</code></pre>
</div>
</div>
<div id="using-selection-the-basics" class="section level2">
<h2>Using <code>selection()</code>: The basics</h2>
<p>Selecting a sample using the <code>selection()</code> function
requires knowledge of units in the population that are eligible for
selection (i.e., sampling units). Sampling units can be items or
monetary units. Items can be selected from the population using record
sampling (also known as attribute sampling or item sampling) with
<code>units = &#39;items&#39;</code>. On the other hand, monetary units can be
selected from the population using monetary unit sampling (MUS) with
<code>units = &#39;values&#39;</code>.</p>
<p>Once the sampling units are determined it should also be determined
what method is used to select the units (i.e., the selection method).
Sampling units can be selected with a fixed interval sampling (also
known as systematic sampling) scheme using
<code>method = &#39;interval&#39;</code> (the default), with a cell sampling
scheme using <code>method = &#39;cell&#39;</code>, using random sampling using
<code>method = &#39;random&#39;</code>, or using modified sieve sampling with
<code>method = &#39;sieve&#39;</code>. See the vignette <a href="https://koenderks.github.io/jfa/articles/v4_selection_methodology.html">Selection:
Sampling methodology</a> for a more detailed explanation the selection
methods implemented in <code>jfa</code>.</p>
<div id="record-sampling" class="section level3">
<h3>Record sampling</h3>
<p>First, let’s take a look at how the <code>selection()</code> function
can be used to perform random record sampling. Random record sampling
implies that the sampling units are set to <code>items</code> and the
selection method is set to <code>random</code>. The code below selects
the 60 planned invoices from the <code>BuildIt</code> data set using
such a random record sampling scheme.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>stage2 <span class="ot">&lt;-</span> <span class="fu">selection</span>(<span class="at">data =</span> BuildIt, <span class="at">size =</span> <span class="dv">60</span>, <span class="at">units =</span> <span class="st">&#39;items&#39;</span>, <span class="at">method =</span> <span class="st">&#39;random&#39;</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(stage2)</span></code></pre></div>
<pre><code>## 
##  Audit Sample Selection Summary
## 
## Options:
##   Requested sample size:         60 
##   Sampling units:                items 
##   Method:                        random sampling 
## 
## Data:
##   Population size:               3500 
## 
## Results:
##   Selected sampling units:       60 
##   Selected items:                60 
##   Proportion of size:            0.017143</code></pre>
</div>
<div id="monetary-unit-sampling-mus" class="section level3">
<h3>Monetary unit sampling (MUS)</h3>
<p>Next, let’s take a look at how the <code>selection()</code> function
can be used to perform fixed interval monetary unit sampling. Fixed
interval monetary unit sampling implies that the sampling units are set
to <code>values</code> and the selection method is set to
<code>interval</code>. The code below selects 150 monetary units from
the <code>BuildIt</code> data set using such a fixed interval monetary
unit sampling scheme.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>stage2 <span class="ot">&lt;-</span> <span class="fu">selection</span>(<span class="at">data =</span> BuildIt, <span class="at">size =</span> <span class="dv">150</span>, <span class="at">units =</span> <span class="st">&#39;values&#39;</span>, <span class="at">method =</span> <span class="st">&#39;interval&#39;</span>, <span class="at">values =</span> <span class="st">&#39;bookValue&#39;</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(stage2)</span></code></pre></div>
<pre><code>## 
##  Audit Sample Selection Summary
## 
## Options:
##   Requested sample size:         150 
##   Sampling units:                monetary units 
##   Method:                        fixed interval sampling 
##   Starting point:                1 
## 
## Data:
##   Population size:               3500 
##   Population value:              1403221 
##   Selection interval:            9354.8 
## 
## Results:
##   Selected sampling units:       150 
##   Proportion of value:           0.0001069 
##   Selected items:                150 
##   Proportion of size:            0.042857</code></pre>
</div>
<div id="extracting-the-sample" class="section level3">
<h3>Extracting the sample</h3>
<p>The selected units and corresponding items are stored in the object
that is returned by the <code>selection()</code> function. The sample
can be extracted from this object by indexing it via
<code>$sample</code>, see the code below. After this step it is up to
the auditor to annotate the sample.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>stage2 <span class="ot">&lt;-</span> <span class="fu">selection</span>(<span class="at">data =</span> BuildIt, <span class="at">size =</span> <span class="dv">60</span>, <span class="at">units =</span> <span class="st">&#39;items&#39;</span>, <span class="at">method =</span> <span class="st">&#39;random&#39;</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>sample <span class="ot">&lt;-</span> stage2<span class="sc">$</span>sample</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(sample, <span class="at">n =</span> <span class="dv">10</span>)</span></code></pre></div>
<pre><code>##     row times    ID bookValue auditValue
## 1  1017     1 50755    618.24     618.24
## 2   679     1 20237    669.75     669.75
## 3  2177     1  9517    454.02     454.02
## 4   930     1 85674    257.82     257.82
## 5  1533     1 31051    308.53     308.53
## 6   471     1 84375    824.66     824.66
## 7  2347     1 75616    623.70     623.70
## 8   270     1 82033    352.75     352.75
## 9  1211     1 12877     52.89      52.89
## 10 3379     1 85322    330.24     330.24</code></pre>
</div>
</div>
<div id="using-evaluation-the-basics" class="section level2">
<h2>Using <code>evaluation()</code>: The basics</h2>
<p>After annotating the items in the sample with their audit values you
can perform statistical inference about the misstatement in the
population with the <code>evaluation()</code> function. Next to a data
sample as input, this function can also be used when only summary
statistics from a data sample (e.g., sample size and number of errors)
are available. For a more elaborate explanation of the output of this
function for each sampling objective, see the package vignettes <a href="https://koenderks.github.io/jfa/articles/v6_testing_misstatement.html">Evaluation:
Testing misstatement</a> and <a href="https://koenderks.github.io/jfa/articles/v5_estimating_misstatement.html">Evaluation:
Estimating misstatement</a>.</p>
<div id="summary-statistics" class="section level3">
<h3>Summary statistics</h3>
<p>First, let’s take a look at how the <code>evaluation()</code>
function can be combined with summary statistics from a sample. Suppose
that in the previously selected sample of 60 invoices it is found that a
single invoice is missing an autograph. These summary statistics can be
provided to the <code>evaluation()</code> function with
<code>x = 1</code> and <code>n = 60</code>. The function also requires
that you specify the sampling objectives using the
<code>materiality</code> or <code>min.precision</code> arguments. Again,
a performance materiality of 5% again applies.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>stage4 <span class="ot">&lt;-</span> <span class="fu">evaluation</span>(<span class="at">materiality =</span> <span class="fl">0.05</span>, <span class="at">method =</span> <span class="st">&#39;poisson&#39;</span>, <span class="at">conf.level =</span> <span class="fl">0.95</span>, <span class="at">x =</span> <span class="dv">1</span>, <span class="at">n =</span> <span class="dv">60</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(stage4)</span></code></pre></div>
<pre><code>## 
##  Classical Audit Sample Evaluation Summary
## 
## Options:
##   Confidence level:               0.95 
##   Materiality:                    0.05 
##   Materiality:                    0.05 
##   Hypotheses:                     H₀: Θ &gt;= 0.05 vs. H₁: Θ &lt; 0.05 
##   Method:                         poisson 
## 
## Data:
##   Sample size:                    60 
##   Number of errors:               1 
##   Sum of taints:                  1 
## 
## Results:
##   Most likely error:              0.016667 
##   95 percent confidence interval: [0, 0.079064] 
##   Precision:                      0.062398 
##   p-value:                        0.19915</code></pre>
<p>The results indicate that the most likely error in the population is
1.66%. Moreover, the 95% one-sided confidence interval for the
population misstatement ranges from 0% to 7.9% and contains the
performance materiality. This implies that we cannot reject the
hypothesis that the population misstatement is lower than 5%, which is
also indicated by a non-significant <em>p</em> value (<em>p</em> =
0.199).</p>
</div>
<div id="data-sample" class="section level3">
<h3>Data sample</h3>
<p>Next, let’s take a look at how the <code>evaluation()</code> function
can be combined with a data sample. Returning to our annotated sample
from the <code>selection()</code> function, suppose that in the
previously selected sample of 60 invoices it is found that a single
invoice has a true value that deviates from its booked value.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>sample<span class="sc">$</span>auditValue    <span class="ot">&lt;-</span> sample<span class="sc">$</span>bookValue</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>sample<span class="sc">$</span>auditValue[<span class="dv">1</span>] <span class="ot">&lt;-</span> sample<span class="sc">$</span>auditValue[<span class="dv">1</span>] <span class="sc">-</span> <span class="dv">100</span></span></code></pre></div>
<p>These data can be provided to the <code>evaluation()</code> function
using the <code>data</code>, <code>values</code>,
<code>values.audit</code>, and <code>times</code> arguments. The
<code>method</code> argument determines the method of inference. For
example, the code below evaluates the misstatement in the population
using the commonly used Stringer bound. You can find more information
about which evaluation methods are implemented on the <a href="https://koenderks.github.io/jfa/">home page</a>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>stage4 <span class="ot">&lt;-</span> <span class="fu">evaluation</span>(<span class="at">materiality =</span> <span class="fl">0.05</span>, <span class="at">method =</span> <span class="st">&#39;stringer&#39;</span>, <span class="at">conf.level =</span> <span class="fl">0.95</span>,</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">data =</span> sample, <span class="at">values =</span> <span class="st">&#39;bookValue&#39;</span>, <span class="at">values.audit =</span> <span class="st">&#39;auditValue&#39;</span>,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">times =</span> <span class="st">&#39;times&#39;</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(stage4)</span></code></pre></div>
<pre><code>## 
##  Classical Audit Sample Evaluation Summary
## 
## Options:
##   Confidence level:               0.95 
##   Materiality:                    0.05 
##   Method:                         stringer 
## 
## Data:
##   Sample size:                    60 
##   Number of errors:               1 
##   Sum of taints:                  0.1617495 
## 
## Results:
##   Most likely error:              0.0026958 
##   95 percent confidence interval: [0, 0.053222] 
##   Precision:                      0.050526</code></pre>
<p>The results indicate that the most likely error in the population is
1%. Moreover, the 95% one-sided confidence interval for the population
misstatement ranges from 0% to 6.5% and contains the performance
materiality. The <code>stringer</code> method does not provide a
<em>p</em> value for hypothesis testing.</p>
</div>
</div>
<div id="using-report-the-basics" class="section level2">
<h2>Using <code>report()</code>: The basics</h2>
<p>With the results from the <code>evaluation()</code> function in hand,
a call to the <code>report()</code> function automatically generates a
report containing the data, the statistical results and their
interpretation, and the conclusion of the sampling procedure with
respect to the sampling objectives. The object returned by the
<code>evaluation()</code> function can be supplied directly to the
<code>report()</code> function, see the code below.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>stage4 <span class="ot">&lt;-</span> <span class="fu">evaluation</span>(<span class="at">materiality =</span> <span class="fl">0.05</span>, <span class="at">method =</span> <span class="st">&#39;stringer&#39;</span>, <span class="at">conf.level =</span> <span class="fl">0.95</span>,</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">data =</span> sample, <span class="at">values =</span> <span class="st">&#39;bookValue&#39;</span>, <span class="at">values.audit =</span> <span class="st">&#39;auditValue&#39;</span>,</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">times =</span> <span class="st">&#39;times&#39;</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="fu">report</span>(stage4, <span class="at">file =</span> <span class="st">&#39;report.html&#39;</span>, <span class="at">format =</span> <span class="st">&#39;html_document&#39;</span>) <span class="co"># Generates .html report</span></span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
